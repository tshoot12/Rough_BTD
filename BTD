
% General stepping algorithm for psychometric functions
% Create an array of zeroes to store user input
trial_number = 50; % How many stimuli will be shown to participants and how many recordings will be done
base_trials = 5; % Estimates beta and alpha
x = -500:500; % amount of ms range to sample from
trial_row = zeros(trial_number,5);
time_interval = 5/1000;% Can be changed to suit specific experiment parameters

real_alpha = -200; % estimated SOA of threshold
real_beta = 3.5; % estimated threshold value
data = nan(length(trial_number),4);
for w = 1:length(x)
    real_p(w) = (1/(1+exp(-1*real_beta*(x(w)-real_alpha))));
end
% Estimate the psychometric function
r_alpha = -500:5:500; % Go from -500ms (left) to 500ms (right) sampling at 5ms
r_beta = 0:0.05:5; % Go from 0 slope to 5 slope every 0.05

x_index = []; % index of x and trial bias whatever that means?
response_1 = []; % response either left or right (7 or 8)
alpha = 0;
beta = 0;

for w = 1:trial_number
    if(w <= init_trials) % During the first 5 trials go get baseline data for half way one quarter and three quarter marks
        switch w
            case 1, x_index = 1;
            case 2, x_index = length(x);
            case 3, x_index = round(length(x)/2);
            case 4, x_index = round(length(x)/4);
            case 5, x_index = round(length(x)*3/4);
        end
    else
        if(rem(w,4) == 0) % what is the 4 for?
            x_index = find(alpha +5 == r_alpha); % varying where the SOA is about the threshold, +/- 5 or at threshold 
        elseif(rem(w,4) == 1)
            x_index = find(alpha - 5 == r_alpha);
        else
            x_index = find(alpha == r_alpha);
        end
    end
    if w == 1 % first trial
        loglike = zeros(length(r_alpha), length (r_beta)); % empty matrix
        r = 0; % no response? 
    else 
        llmax = -Inf; % loglike max?  otherwise biggest value os negative infinity 
        for alpha_value = 1:length(r_alpha); % length of SOA
            for beta_value = 1:length(r_beta); % length of slope, does that even make sense
                p = 1/(1+exp(r_beta(beta_value)*r_alpha(alpha_value)- x(x_index))); % same equation with variables 
                
    % Create dialog box to enter participant number in
    prompt = {'Enter Participant Number:'}; % Citation: dialog box code found on: http://www.mathworks.com/help/matlab/ref/inputdlg.html?refresh=true, last access was November 26th 2015
    dlg_title = 'Participant Number';
    num_lines = 1;
    answer = inputdlg(prompt,dlg_title,num_lines);
    % Convert participant number from a character into a number
    participant_number = str2double(answer{1});
    % Ensure that participant number is a number and not a NaN
    if isfinite(participant_number)
        participant_row = participant_number;
    else
        error('Participant Number must be a number')
    end
    
    % Translate key numbers into allocated names
    KbName('UnifyKeyNames');
    leftKey = KbName('LeftArrow');
    rightKey = KbName('RightArrow');
    quitKey = KbName('ESCAPE');
    enterKey = KbName('return');
    
    %Start up PTB
    Main_Screen = 0; % Citation: screen set up, text descriptions and flips found on exampleExperiment.m by Dr. David Hunter
    Screen('Preference', 'SkipSyncTests',0);
    
    % Figures out screen resolution and calculates how to centre a shape
    [wPtr,rect] = Screen('OpenWindow',0);
    screenWidth = rect(3);
    screenHeight = rect(4);
    screenCenterX = screenWidth/2;
    screenCenterY = screenHeight/2;
    
    % Set height and width of shape
    myOvalWidth = 100;
    myOvalHeight = 100;
    
    % Center shape
    myOvalLeft = screenCenterX - myOvalWidth/2;
    myOvalTop = screenCenterY - myOvalHeight/2;
    myOvalRight = myOvalLeft + myOvalWidth;
    myOvalBottom = myOvalTop + myOvalHeight;
    myOval = [myOvalLeft, myOvalTop, myOvalRight, myOvalBottom];
    
    % Set height and width of shape
    myRectWidth = 50;
    myRectHeight = 50;
    
    % Center shape
    myRectLeft = screenCenterX - myRectWidth/2;
    myRectTop = screenCenterY - myRectHeight/2;
    myRectRight = myRectLeft + myRectWidth;
    myRectBottom = myRectTop + myRectHeight;
    myRect = [myRectLeft, myRectTop, myRectRight, myRectBottom];
    
    % create a new response variable to store one response per stimulus
    response = double(1);
    
    
    
    for currentStimulus = 1:trial_number;
        SOA = 10; % asynchrony between the two stimuli, change this?
        % Store the trial and participant number into growing matrix
        trial_row(currentStimulus,1)= participant_row;
        trial_row(currentStimulus,2)= currentStimulus;
        
        % Set the default to randomly choose 1 or 2
        default = randperm(2,1);
        
        % default first stimulus, if 1 then goes to the left, if 2 then goes to
        % the right
        if default < 2
            myOval = [myOvalLeft - 300, myOvalTop, myOvalRight - 300, myOvalBottom]; % translates circle 300 pixels
            myOval2 = [myOvalLeft + 300, myOvalTop, myOvalRight + 300, myOvalBottom]; % translates circle 300 pixels
        else
            myOval = [myOvalLeft + 300, myOvalTop, myOvalRight + 300, myOvalBottom];
            myOval2 = [myOvalLeft - 300, myOvalTop, myOvalRight - 300, myOvalBottom];
        end
        
        % Record whether 1 or 2 was chosen into growing matrix
        trial_row(currentStimulus,3) = default;
        % Wait some time so KbWait does not advance too quickly
        WaitSecs(time_interval);
        
        % Draw circle to screen
        Screen('FillRect', wPtr, 0, myRect);
        Screen('FillOval',wPtr,[255 0 0 ],myOval)
        Screen('Flip',wPtr);
        
        WaitSecs(SOA);
        
        % Draw circle to screen
        Screen('FillRect', wPtr, 0, myRect);
        Screen('FillOval',wPtr,[0 0 255 ],myOval2)
        Screen('Flip',wPtr);
        
        WaitSecs(time_interval);
        
        % Only look for key presses for the relevant keys
        RestrictKeysForKbCheck([leftKey,rightKey, quitKey]);
        
        % Time zero for reaction time
        secs0 = GetSecs; % Citation: calculating RT by Rachel Cooper under 'Creating experiments using Matlab and Psychtoolbox' accessed November 17th 2015, can be found on: https://www.academia.edu/2614964/Creating_experiments_using_Matlab_and_Psychtoolbox
        
        % Wait for keypress and release, only accurate to the nearest 5ms
        KbWait;
        
        % Check what key was pressed
        [keyIsDown, secs, keyCode] = KbCheck;% Citation: Rachel Cooper, accessed November 17th 2015, see full citation above. Modified, deleted deltasecs
        
        % Wait for key to be released, extremely important
        KbReleaseWait;
        
        % Stores the user response associated with direction of stimulus, 7 =
        % left, 8 = right, otherwise quit is pressed and error comes up
        if keyCode(leftKey)
            response = 7;
        elseif keyCode(rightKey)
            response = 8;
        elseif keyCode(quitKey)
            Screen('CloseAll');
            error('User hit the quit key');
        end
        
        % Calculate reaction time
        RT = secs - secs0; %Citation, for RT calculation as well: Rachel Cooper, accessed November 17th 2015, see full citation above
        
        % Assign responses (left or right keypress) into growing matrix
        trial_row(currentStimulus,4) = response;
        
        % Record reaction time in matrix
        trial_row(currentStimulus,5) = RT;
        
    end
    
    % Debrief message after experiment is complete
    debrief = 'The experiment is now over, press enter to quit back to Matlab.';
    
    % White screen with specified text values
    Screen('FillRect',wPtr,[ 255 255 255 255]); % Citation, text, restricting keys and screen: exampleExperiment.m by Dr. David Hunter
    Screen('TextFont',wPtr, 'Courier New');
    Screen('TextSize',wPtr, 14);
    Screen('TextStyle', wPtr, 1+2);
    DrawFormattedText(wPtr, debrief, 10, 20, [0 0 0 255], 40);
    
    % Bring screen from the back to the front so the participant can see it
    Screen('Flip', wPtr);
    
    % Restrict keypresses to the enter/return key, wait for keypress
    RestrictKeysForKbCheck(enterKey);
    KbWait
    
    % Close Psychtoolbox
    Screen('CloseAll')
    
    dlmwrite('BTD_Results.csv',trial_row,'delimiter', ',','-append');
